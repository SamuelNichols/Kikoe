// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts"

const UA =
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

export type YtCfg = {
  key: string;
  clientName: string;
  clientVersion: string;
};

export type CaptionTrack = {
  baseUrl: string;
  languageCode: string;
  name: string;
  vssId?: string;
  kind?: string; // "asr" means auto-generated
  isTranslatable?: boolean;
  autoGenerated: boolean; // derived: kind==="asr" or vssId starts with "a."
};

export type CaptionsListResponse = {
  videoId: string;
  tracks: CaptionTrack[];
  translationLanguages: Array<{ languageCode: string; name: string }>;
  defaultAudioTrackIndex?: number;
};

type PlayerResponse = {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: any[];
      translationLanguages?: Array<{ languageCode: string; languageName: any }>;
      defaultAudioTrackIndex?: number;
    };
  };
};

type AvailableCaptionUrls = {
  [key: string]: string;
}

export type RawCaptions = {
  [key: string]: string;
}

// --- Utilities ---------------------------------------------------------------

const safeName = (n: any): string =>
  (n?.simpleText as string)
  ?? (Array.isArray(n?.runs) ? n.runs.map((r: any) => r?.text ?? "").join("") : "")
  ?? "";

// Return parsed list of available caption tracks (and translation langs)
const parseCaptionsList = (videoId: string, player: PlayerResponse): CaptionsListResponse => {
  const tl = player?.captions?.playerCaptionsTracklistRenderer;

  const tracks: CaptionTrack[] = (tl?.captionTracks ?? []).map((ct: any) => {
    const kind = ct?.kind as string | undefined;
    const vssId = ct?.vssId as string | undefined;
    return {
      baseUrl: String(ct?.baseUrl ?? ""),
      languageCode: String(ct?.languageCode ?? ""),
      name: safeName(ct?.name),
      vssId,
      kind,
      isTranslatable: Boolean(ct?.isTranslatable),
      autoGenerated: kind === "asr" || (typeof vssId === "string" && vssId.startsWith("a.")),
    };
  });

  // Optional: de-duplicate by (languageCode, autoGenerated) because some videos
  // return multiple entries that only differ by tiny params.
  const dedup = new Map<string, CaptionTrack>();
  for (const t of tracks) {
    const key = `${t.languageCode}::${t.autoGenerated ? "asr" : "human"}`;
    if (!dedup.has(key)) dedup.set(key, t);
  }

  const translationLanguages =
    (tl?.translationLanguages ?? []).map((l: any) => ({
      languageCode: String(l?.languageCode ?? ""),
      name: safeName(l?.languageName),
    }));

  return {
    videoId,
    tracks: Array.from(dedup.values()),
    translationLanguages,
    defaultAudioTrackIndex: tl?.defaultAudioTrackIndex,
  };
};

// --- Network calls -----------------------------------------------------------

// Fetch the ytcfg from the watch page
const getYtcfg = async (videoId: string): Promise<YtCfg> => {
  const url = `https://www.youtube.com/watch?v=${videoId}`;
  const response = await fetch(url, {
    headers: { "user-agent": UA, "accept-language": "en" },
  });
  const data = await response.text();

  const match = data.match(/ytcfg\.set\(({.+?})\);/s);
  if (!match) throw new Error("ytcfg not found!");

  const cfg = JSON.parse(match[1]);
  const key = cfg.INNERTUBE_API_KEY;
  const clientName = cfg.INNERTUBE_CONTEXT_CLIENT_NAME || cfg.CLIENT_NAME;
  const clientVersion = cfg.INNERTUBE_CONTEXT_CLIENT_VERSION || cfg.CLIENT_VERSION;

  if (!key) throw new Error("INNERTUBE_API_KEY not found");
  return { key, clientName, clientVersion };
};

// Get the full player response JSON (this includes captions metadata)
const getPlayer = async (videoId: string, ytcfg: YtCfg): Promise<PlayerResponse> => {
  const url = `https://www.youtube.com/youtubei/v1/player?key=${encodeURIComponent(ytcfg.key)}`;
  const body = {
    context: {
      client: {
        clientName: ytcfg.clientName,
        clientVersion: ytcfg.clientVersion,
        hl: "en",
        gl: "JP",
      },
    },
    videoId,
  };

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", "User-Agent": UA },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`player fetch failed: ${res.status} ${res.statusText} ${text}`);
  }

  return res.json();
};

const getAllCaptionsByUrl = async (availableCaptionUrls: AvailableCaptionUrls): Promise<RawCaptions> => {
  // return as map key -> xml-string
  const captions = await Promise.all(Object.entries(availableCaptionUrls).map(async ([key, url]) => {
    const res = await fetch(url);
    const text = await res.text();
    return { [key]: text };
  }));
  return captions.reduce((acc, caption) => ({ ...acc, ...caption }), {} as RawCaptions);
}

// Convenience: one-shot list function you can import/use elsewhere
export const getAvailableCaptions = async (videoId: string): Promise<RawCaptions> => {
  const ytcfg = await getYtcfg(videoId);
  const player = await getPlayer(videoId, ytcfg);
  const captionsList = parseCaptionsList(videoId, player);
  const availableCaptionUrls: AvailableCaptionUrls = captionsList.tracks.reduce((acc, track) => {
    const kind = track.kind === "asr" ? "autoGenerated" : "humanGenerated";
    const key = `${kind}::${track.languageCode}`;
    acc[key] = track.baseUrl;
    return acc;
  }, {} as AvailableCaptionUrls);
  return getAllCaptionsByUrl(availableCaptionUrls);
};

// --- Edge function entry -----------------------------------------------------

export type FetchSubsRequestBody = { videoId: string };

Deno.serve(async (req: Request) => {
  try {
    if (req.method === "OPTIONS") {
      return new Response("ok", { headers: corsHeaders });
    }
    if (req.method !== "POST") {
      return new Response("Only POST", { status: 405, headers: corsHeaders });
    }

    const { videoId } = (await req.json()) as FetchSubsRequestBody;
    if (!videoId) {
      return new Response(JSON.stringify({ error: "Missing videoId" }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    const result = await getAvailableCaptions(videoId);

    return new Response(JSON.stringify(result), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (err: any) {
    return new Response(JSON.stringify({ error: String(err?.message ?? err) }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});